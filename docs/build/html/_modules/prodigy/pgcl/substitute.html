<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>prodigy.pgcl.substitute &#8212; Prodigy  documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/katex-math.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"></script>
    <script src="../../../_static/katex_autorenderer.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;1,400&family=Source+Serif+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body {
            font: 15px/1.4 "Source Sans Pro",sans-serif;
        }
        h1, h2, h3, h5, h6, h6 {
            font-family: "Source Sans Pro",sans-serif;
        }
        p {
            font-family: "Source Serif Pro",serif;
        }
        .py, .field-list p, pre, code {
            font-family: 'Source Code Pro', monospace;
        }

        /* fix navbar overlaying contents when clicking on anchors */
        :target::before {
            content: "";
            display: block;
            height: 60px; /* fixed header height*/
            margin: -60px 0 0; /* negative fixed header height */
            background: none;
        }

        /* hack to limit the yellow highlight to the the children of the target,
           because of the above hack the target's highlight would be way too large */
        dt:target {
            background-color: transparent;
        }
        dt:target > * {
            background-color: #fbe54e;
        }

        /* spacing adjustments */
        .section {
            margin-bottom: 10rem;
            margin-top: 6rem;
        }
        div.body > .section:first-of-type {
            margin-top: 0rem;
        }
        .class, .function, .data {
            margin-top: 5rem;
            margin-bottom: 7rem;
            border-left: 1px solid #eee;
            padding-left: 1rem;
        }
        dl.attribute > dd, dl.class > dd, dl.function > dd, dl.method > dd {
            margin-left: 30px;
        }
        p {
            margin-top: 1.05em;
            margin-bottom: 1.05em;
            text-align: justify;
        }
        .field-list p, li p {
            text-align: left;
        }
        /* adjust font sizes */
        dl.field-list, dl.attribute {
            font-size: 90%;
        }
        .math {
            font-size: 90.09%;
        }
    </style>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          Prodigy</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/Philipp15b/probably">GitHub Repository</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pysmt.html"><code class="docutils literal notranslate"><span class="pre">probably.pysmt</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html"><code class="docutils literal notranslate"><span class="pre">probably.analysis</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html"><code class="docutils literal notranslate"><span class="pre">probably.util</span></code></a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
<h4 style="padding: 5px 20px">Contents</h4>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pysmt.html"><code class="docutils literal notranslate"><span class="pre">probably.pysmt</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html"><code class="docutils literal notranslate"><span class="pre">probably.analysis</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html"><code class="docutils literal notranslate"><span class="pre">probably.util</span></code></a></li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <h1>Source code for prodigy.pgcl.substitute</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">---------------------</span>
<span class="sd">Variable Substitution</span>
<span class="sd">---------------------</span>

<span class="sd">This module does variable substitution for expressions, expectations, and programs.</span>
<span class="sd">The purpose of this module is elimination of :class:`SubstExpr` by applying the corresponding substitutions.</span>

<span class="sd">.. note::</span>

<span class="sd">    The program must be well-typed.</span>
<span class="sd">    In particular, variables must be defined before they are used and substitutions must be type-safe.</span>

<span class="sd">.. warning::</span>

<span class="sd">    The input AST **must be a tree** and objects may not occur multiple times. This is a limitation of the current implementation.</span>
<span class="sd">    General DAGs are not supported yet.</span>

<span class="sd">.. warning::</span>

<span class="sd">    **Substitutions reuse AST objects**, and do not copy unnecessarily.</span>
<span class="sd">    Thus, AST objects may turn up multiple times in the AST.</span>
<span class="sd">    For later mutation of the AST, you may want to pass `deepcopy = True` to prevent spooky action action at a distance.</span>

<span class="sd">.. _substitute_symbolic_variables:</span>

<span class="sd">.. rubric:: Symbolic variables</span>

<span class="sd">Each substitution function takes a parameter `symbolic` parameter that is a set of variables to be taken symbolic.</span>
<span class="sd">Symbolic variables are placeholders for arbitrary expressions, and thus it is not known which variables they contain.</span>
<span class="sd">Therefore the substitution cannot be done at this time.</span>
<span class="sd">Instead, a substitution applied to a symbolic variable will wrap the variable in a :class:`SubstExpr` that contains all substitutions applied to this variable.</span>

<span class="sd">.. doctest::</span>

<span class="sd">    &gt;&gt;&gt; from prodigy.util.ref import Mut</span>
<span class="sd">    &gt;&gt;&gt; from .ast import SubstExpr, NatLitExpr, VarExpr</span>
<span class="sd">    &gt;&gt;&gt; from .parser import parse_expr</span>

<span class="sd">    Simple substitution without symbolic variables:</span>
<span class="sd">    &gt;&gt;&gt; expr_ref = Mut.alloc(SubstExpr({&quot;x&quot;: NatLitExpr(2)}, parse_expr(&quot;x + y&quot;)))</span>
<span class="sd">    &gt;&gt;&gt; substitute_expr(expr_ref)</span>
<span class="sd">    &gt;&gt;&gt; str(expr_ref.val)</span>
<span class="sd">    &#39;2 + y&#39;</span>

<span class="sd">    The same substitution with `y` being symbolic:</span>
<span class="sd">    &gt;&gt;&gt; expr_ref = Mut.alloc(SubstExpr({&quot;x&quot;: NatLitExpr(2)}, parse_expr(&quot;x + y&quot;)))</span>
<span class="sd">    &gt;&gt;&gt; substitute_expr(expr_ref, symbolic=set(&quot;y&quot;))</span>
<span class="sd">    &gt;&gt;&gt; str(expr_ref.val)</span>
<span class="sd">    &#39;2 + ((y)[x/2])&#39;</span>

<span class="sd">.. rubric:: Implementation notes</span>

<span class="sd">.. seealso::</span>

<span class="sd">    `Documentation of internal classes and functions &lt;substitute_internals.html&gt;`_ can be found on another page.</span>

<span class="sd">The implementation is much more sophisticated than the simple approach of doubly-recursive bottom-up substition application.</span>
<span class="sd">For comparison, the simple approach is available in `tests/test_substitution.py` and used to test this implementation.</span>
<span class="sd">In this module, we implement a different approach using generated local variables for each substitution.</span>

<span class="sd">First the `binding` phase, top-down (implemented in :func:`_Binder.bind`):</span>

<span class="sd">1. For each substitution expression and each substitution `x/y`, generate a new local variable `t`.</span>
<span class="sd">2. Run all current substitutions on `y`, generating `y&#39;`.</span>
<span class="sd">3. Now remember two substitutions: `x/t` and `t/y&#39;`.</span>
<span class="sd">4. Recurse into the substitutions&#39; children.</span>

<span class="sd">Then the `resolve` phase (direction is irrelevant, implemented in :func:`_Binder.resolve`):</span>

<span class="sd">1. On the generated substitutions for local variables, replace all simple ones of the form `t1/t2`, resolving `t2` recursively. Now the object references to be inserted in the AST are final (not necessarily nested objects).</span>
<span class="sd">2. Now we update the objects to be inserted in the AST, i.e. all replacements of the form `t1/r` for general expressions `r` are updated by replacing all locals `t_i` occuring in `r`. All substitutions are now final.</span>
<span class="sd">3. Replace all locals in the expression itself.</span>

<span class="sd">Except for step 1 of the `resolve` phase, all phases clearly take linear time.</span>
<span class="sd">Step 1 of `resolve` is only run for simple chains of substitutions with no nested locals (e.g. generated from ``x[x/y][y/z]``), and the step also amortizes lookups.</span>
<span class="sd">So basically we have linear runtime.</span>

<span class="sd">This implementation was very loosely inspired by an article [#locallynameless]_ on &quot;locally nameless&quot; substitution based on the awesomely titled paper &quot;I am not a Number â€” I am a Free Variable&quot; [#haskell2004]_.</span>


<span class="sd">.. rubric:: Footnotes</span>

<span class="sd">.. [#locallynameless] https://boarders.github.io/posts/locally-nameless/</span>
<span class="sd">.. [#haskell2004] &quot;I am not a number: I am a free variable&quot; (2004) by McBride and McKinna.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">copylib</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">attr</span>

<span class="kn">from</span> <span class="nn">prodigy.util.ref</span> <span class="kn">import</span> <span class="n">Mut</span>

<span class="kn">from</span> <span class="nn">.ast</span> <span class="kn">import</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">ExprClass</span><span class="p">,</span> <span class="n">Program</span><span class="p">,</span> <span class="n">SubstExpr</span><span class="p">,</span> <span class="n">Var</span><span class="p">,</span> <span class="n">VarExpr</span>
<span class="kn">from</span> <span class="nn">prodigy.pgcl.ast.walk</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Walk</span><span class="p">,</span> <span class="n">mut_expr_children</span><span class="p">,</span> <span class="n">mut_instr_exprs</span><span class="p">,</span> <span class="n">walk_expr</span><span class="p">,</span>
                                   <span class="n">walk_instrs</span><span class="p">)</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="nb">hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_BoundExpr</span><span class="p">(</span><span class="n">ExprClass</span><span class="p">):</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;BoundExpr(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s1">)&#39;</span>


<div class="viewcode-block" id="_Binder"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Binder">[docs]</a><span class="k">class</span> <span class="nc">_Binder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All substitutions (the `values` in the `subst` dict) are assigned a numeric identifier.</span>
<span class="sd">    The binder manages those.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_bound</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>
    <span class="n">_deepcopy</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bound</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deepcopy</span> <span class="o">=</span> <span class="n">deepcopy</span>

<div class="viewcode-block" id="_Binder.bind"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Binder.bind">[docs]</a>    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_BoundExpr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the given expression to the binder, return a new :class:`_BoundExpr`</span>
<span class="sd">        that points to the expression in the binder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bound_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_BoundExpr</span><span class="p">(</span><span class="n">bound_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="_Binder.resolve"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Binder.resolve">[docs]</a>    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In the internal list of bound expressions, replace all</span>
<span class="sd">        :class:`_BoundExpr` by the the bound expressions.</span>

<span class="sd">        Cycles are handled using a two-step procedure (see module docs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first resolve all top-level bindings</span>
        <span class="k">for</span> <span class="n">expr_ref</span> <span class="ow">in</span> <span class="n">Mut</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bound</span><span class="p">):</span>
            <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">):</span>
                <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># now that all top-level references in self.bound are final,</span>
        <span class="c1"># we can iterate over all expressions and insert them one by one.</span>
        <span class="c1"># since the references are stable, changes to an inserted expression</span>
        <span class="c1"># will occur everywhere else in the AST it appears as well.</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bound</span><span class="p">:</span>
            <span class="n">expr_ref</span> <span class="o">=</span> <span class="n">Mut</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subexpr_ref</span> <span class="ow">in</span> <span class="n">walk_expr</span><span class="p">(</span><span class="n">Walk</span><span class="o">.</span><span class="n">DOWN</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subexpr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">):</span>
                    <span class="n">subexpr_ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">subexpr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subexpr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">expr</span> <span class="ow">is</span> <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;expression refs must be stable&quot;</span></div>

<div class="viewcode-block" id="_Binder.lookup"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Binder.lookup">[docs]</a>    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bound</span><span class="p">:</span> <span class="n">_BoundExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a :class:`_BoundExpr`, return the associated expression.</span>

<span class="sd">        _Deepcopies_ the expression if ``deepcopy`` is set to ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bound</span><span class="p">[</span><span class="n">bound</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deepcopy</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">copylib</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div></div>


<div class="viewcode-block" id="_Subst"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Subst">[docs]</a><span class="k">class</span> <span class="nc">_Subst</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data structure for current substitutions to be applied.</span>

<span class="sd">    * It holds a mapping for the substitutions itself (Var/BoundExpr to BoundExpr),</span>
<span class="sd">    * and the set of symbolic variables that cannot be substituted (see section :ref:`substitute_symbolic_variables` for more information).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_subst</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">],</span> <span class="n">_BoundExpr</span><span class="p">]</span>
    <span class="n">_symbolic</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">subst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">],</span>
                                      <span class="n">_BoundExpr</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">symbolic</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Var</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subst</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">subst</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">subst</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic</span> <span class="o">=</span> <span class="n">symbolic</span>

<div class="viewcode-block" id="_Subst.add_bound"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Subst.add_bound">[docs]</a>    <span class="k">def</span> <span class="nf">add_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binder</span><span class="p">:</span> <span class="n">_Binder</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">],</span>
                  <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bind the expression using ``binder``, then add a new substitution that</span>
<span class="sd">        replaces ``var`` by the newly created bound expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bound_expr</span> <span class="o">=</span> <span class="n">binder</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subst</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_expr</span></div>

<div class="viewcode-block" id="_Subst.apply"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Subst.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_expr</span><span class="p">:</span> <span class="n">VarExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the substitutions to the given variable expression. Symbolic</span>
<span class="sd">        variables are replaced by new substitution expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var_expr</span><span class="o">.</span><span class="n">var</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mk_subst_expr</span><span class="p">(</span><span class="n">var_expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subst</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subst</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>  <span class="c1"># type:ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var_expr</span></div>

    <span class="k">def</span> <span class="nf">_mk_subst_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubstExpr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a substitution expression around `body`.</span>
<span class="sd">        Used for symbolic variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># cheating with types here a bit</span>
        <span class="n">subst_cast</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subst</span>  <span class="c1"># type:ignore</span>
        <span class="k">return</span> <span class="n">SubstExpr</span><span class="p">(</span><span class="n">subst_cast</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

<div class="viewcode-block" id="_Subst.copy"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._Subst.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_Subst&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a new copy of this substitution dictionary, for use in branching</span>
<span class="sd">        expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Subst</span><span class="p">(</span><span class="n">subst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subst</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbolic</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="_bind_substs"><a class="viewcode-back" href="../../../substitute_internals.html#prodigy.pgcl.substitute._bind_substs">[docs]</a><span class="k">def</span> <span class="nf">_bind_substs</span><span class="p">(</span><span class="n">binder</span><span class="p">:</span> <span class="n">_Binder</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">_Subst</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">:</span> <span class="n">Mut</span><span class="p">[</span><span class="n">Expr</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Walk the `expr_ref` and replace all right-hand sides of each :class:`SubstExpr` by a locally bound :class:`_BoundExpr`.</span>


<span class="sd">    This test asserts the order in which substitutions are applied: First inner</span>
<span class="sd">    ones, then outer.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; binder = _Binder(deepcopy=False)</span>
<span class="sd">        &gt;&gt;&gt; subst = _Subst(symbolic=set())</span>
<span class="sd">        &gt;&gt;&gt; expr = SubstExpr({&#39;x&#39;: VarExpr(&#39;x1&#39;)}, SubstExpr({&#39;x&#39;: VarExpr(&#39;x2&#39;)}, VarExpr(&#39;x&#39;)))</span>
<span class="sd">        &gt;&gt;&gt; expr_ref = Mut.alloc(expr)</span>
<span class="sd">        &gt;&gt;&gt; _bind_substs(binder, subst, expr_ref)</span>
<span class="sd">        &gt;&gt;&gt; str(expr_ref.val)</span>
<span class="sd">        &#39;BoundExpr(1)&#39;</span>
<span class="sd">        &gt;&gt;&gt; binder.lookup(expr_ref.val)</span>
<span class="sd">        VarExpr(&#39;x2&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span>

    <span class="c1"># Apply the substitution on variables, inserting either the replacement</span>
    <span class="c1"># or wrapping the variable with a SubstExpr in case of a symbolic variable.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">VarExpr</span><span class="p">):</span>
        <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">subst</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Substitutions have their right-hand side replaced by locally-bound variables.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">SubstExpr</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">expr</span><span class="o">.</span><span class="n">subst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Substitution expression must not be visited twice&quot;</span>
        <span class="k">for</span> <span class="n">subst_expr_ref</span> <span class="ow">in</span> <span class="n">Mut</span><span class="o">.</span><span class="n">dict_values</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">subst</span><span class="p">):</span>
            <span class="c1"># Assert that we have not visited this SubstExpr before (this can happen when objects</span>
            <span class="c1"># occur multiple times in the AST).</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subst_expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">)</span>

            <span class="n">_bind_substs</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">subst</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">subst_expr_ref</span><span class="p">)</span>

        <span class="n">subst</span> <span class="o">=</span> <span class="n">subst</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># open a new subscope</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">subst_expr</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">subst</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subst</span><span class="o">.</span><span class="n">add_bound</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">subst_expr</span><span class="p">)</span>

        <span class="c1"># as a safety guard, invalidate the consumed SubstExpr</span>
        <span class="n">expr</span><span class="o">.</span><span class="n">subst</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># replace this SubstExpr by its body</span>
        <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr</span>
        <span class="n">_bind_substs</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># the default case: apply to children</span>
    <span class="k">for</span> <span class="n">child_expr_ref</span> <span class="ow">in</span> <span class="n">mut_expr_children</span><span class="p">(</span><span class="n">expr_ref</span><span class="p">):</span>
        <span class="n">_bind_substs</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">child_expr_ref</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_resolve_bound_exprs</span><span class="p">(</span><span class="n">binder</span><span class="p">:</span> <span class="n">_Binder</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">:</span> <span class="n">Mut</span><span class="p">[</span><span class="n">Expr</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">child_expr_ref</span> <span class="ow">in</span> <span class="n">walk_expr</span><span class="p">(</span><span class="n">Walk</span><span class="o">.</span><span class="n">UP</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">):</span>
            <span class="n">child_expr_ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">binder</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">child_expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">SubstExpr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subst_lhs</span> <span class="ow">in</span> <span class="n">child_expr_ref</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">subst</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subst_lhs</span><span class="p">,</span> <span class="n">_BoundExpr</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">subst_expr_ref</span> <span class="ow">in</span> <span class="n">Mut</span><span class="o">.</span><span class="n">dict_values</span><span class="p">(</span><span class="n">child_expr_ref</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">subst</span><span class="p">):</span>
                <span class="n">_resolve_bound_exprs</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">subst_expr_ref</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">substitute_expr</span><span class="p">(</span><span class="n">expr_ref</span><span class="p">:</span> <span class="n">Mut</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span>
                    <span class="o">*</span><span class="p">,</span>
                    <span class="n">symbolic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Var</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">deepcopy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply substitutions in this expression/expectation.</span>
<span class="sd">    After execution, the `expr_ref` contains no :class:`SubstExpr` anywhere except directly around `symbolic` variables.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr_ref: The reference to the expression to be modified.</span>
<span class="sd">        symbolic: The set of symbolic variables. See the module description.</span>
<span class="sd">        deepcopy: Whether to call `deepcopy` on each replacement, i.e. not reuse any AST objects in substitutions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binder</span> <span class="o">=</span> <span class="n">_Binder</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">)</span>
    <span class="n">subst</span> <span class="o">=</span> <span class="n">_Subst</span><span class="p">(</span>
        <span class="n">symbolic</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">symbolic</span><span class="p">)</span> <span class="k">if</span> <span class="n">symbolic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">frozenset</span><span class="p">())</span>
    <span class="n">_bind_substs</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">)</span>
    <span class="n">binder</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
    <span class="n">_resolve_bound_exprs</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">substitute_constants_expr</span><span class="p">(</span><span class="n">program</span><span class="p">:</span> <span class="n">Program</span><span class="p">,</span>
                              <span class="n">expr_ref</span><span class="p">:</span> <span class="n">Mut</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span>
                              <span class="o">*</span><span class="p">,</span>
                              <span class="n">symbolic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Var</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substitute constants in this expression/expectation.</span>

<span class="sd">    Args:</span>
<span class="sd">        program: The program with variable declarations.</span>
<span class="sd">        expr_ref: The reference to the expression to be modified.</span>
<span class="sd">        symbolic: The set of symbolic variables. See the module description.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">SubstExpr</span><span class="p">(</span><span class="n">program</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">expr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">substitute_expr</span><span class="p">(</span><span class="n">expr_ref</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="n">symbolic</span><span class="p">,</span> <span class="n">deepcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">substitute_constants</span><span class="p">(</span><span class="n">program</span><span class="p">:</span> <span class="n">Program</span><span class="p">,</span>
                         <span class="o">*</span><span class="p">,</span>
                         <span class="n">symbolic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Var</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substitute constants in this program.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; from prodigy.pgcl.parser import parse_pgcl</span>
<span class="sd">        &gt;&gt;&gt; program = parse_pgcl(&quot;const x := 23; nat y; nat z; y := x; z := y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; substitute_constants(program)</span>
<span class="sd">        &gt;&gt;&gt; program.instructions</span>
<span class="sd">        [AsgnInstr(lhs=&#39;y&#39;, rhs=NatLitExpr(23)), AsgnInstr(lhs=&#39;z&#39;, rhs=VarExpr(&#39;y&#39;))]</span>

<span class="sd">    Args:</span>
<span class="sd">        program: The program to be modified.</span>
<span class="sd">        symbolic: The set of symbolic variables. See the module description.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">const_ref</span> <span class="ow">in</span> <span class="n">Mut</span><span class="o">.</span><span class="n">dict_values</span><span class="p">(</span><span class="n">program</span><span class="o">.</span><span class="n">constants</span><span class="p">):</span>
        <span class="n">substitute_constants_expr</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="n">const_ref</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">instr_ref</span> <span class="ow">in</span> <span class="n">walk_instrs</span><span class="p">(</span><span class="n">Walk</span><span class="o">.</span><span class="n">DOWN</span><span class="p">,</span> <span class="n">program</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">expr_ref</span> <span class="ow">in</span> <span class="n">mut_instr_exprs</span><span class="p">(</span><span class="n">instr_ref</span><span class="o">.</span><span class="n">val</span><span class="p">):</span>
            <span class="n">substitute_constants_expr</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="n">expr_ref</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="n">symbolic</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2022, Lutz Klinkenberg.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>